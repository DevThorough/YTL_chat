{
    "nIp604p0M8M": {
        "videoId": "nIp604p0M8M",
        "title": "Regular Operations",
        "publishedAt": "2020-10-01T10:05:58Z",
        "stats": {
            "viewCount": "19990",
            "likeCount": "748",
            "favoriteCount": "0",
            "commentCount": "19"
        },
        "captions": "Kind: captions Language: en recall that a regular language is a language that is recognized by some finite automaton for example the language containing the string 1 0 is a regular language since we can construct this machine that will accept 1-0 we also know about the union concatenation and star operation for languages if you aren't familiar with these operations we have a video on them which we highly recommend you first check out links will be in the description below so given that we know what regular languages and operations are then what are regular operations well the term regular operations is just another way of classifying the operations union concatenation and star as all of them contain a certain property which is that when operated on any regular language the resulting language will still be a regular language formally we say that the class of regular languages is closed under these operations now since the resulting languages are regular languages by definition we must be able to construct finite automata that recognize these languages we won't be going through the formal proof in this video but here is the idea let's say a is a language containing any string that starts with one one and b is a language containing any string that ends in zero a and b are both regular languages since we can construct finite automata for them here's a dfa that recognizes a and here is a dfa that recognizes b now here's how we can construct a new finite automaton that recognizes their union remember we are doing this to show that the union of two regular languages will still be a regular language so since the union of a and b means the resulting language will contain all strings that are either in a or b then we know that at the end of an input we should enter the accept state of one of these dfas knowing this how can we create a new machine for a union b we do that by taking the two dfas and combining them by adding a new start state which transitions to a's dfa or b's dfa on an empty string recall that the empty string transition gives our machine the choice of going either way without reading anything from the input string like a free jump that a running machine could take by doing this we create a new non-deterministic finite automaton or nfa that accepts the strings in a or in b recall that nfas will accept the string as long as there is one possible path that leads to intercept state so notice how it accepts 1 1 1 which belongs in a or it can accept 0 0 which belongs in b if you aren't sure how the empty string or nfas work the link to our video on nfas is in the description below otherwise that's it our new finite automaton that recognizes a union b again we constructed this nfa to show that the union of two regular languages will still be a regular language formerly put the class of regular languages is closed under union and because the concatenation and star operators are also regular operations that means a class of regular languages is also closed under concatenation and star and will be able to do something similar to what we did earlier with union and construct finite automata for their resulting languages it might also be worth noting that a class of regular languages are also closed under intersection and complement as well though these operations are not called regular operations so here is the big question what is the significance of regular operations why are they even called regular operations well given some alphabet which is just some set of symbols if we were to start with some very small set of initial languages over said alphabet specifically each symbol that is in the alphabet the language containing the empty string and the language that is the empty set by applying only those three regular operations over them we will be able to generate all the regular languages over that alphabet this will be revisited as we start looking at regular expressions next to summarize everything in the video the regular operations are the union concatenation and star operations on languages regular languages are closed under the regular operations and finally we can prove this by constructing new machines that recognize the resulting languages"
    }
}